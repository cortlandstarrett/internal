========================================================================

File:      $RCSfile$
Version:   $Revision$
Modified:  $Date$

(c) Copyright 2008-2009 by Mentor Graphics Corp. All rights reserved.

========================================================================
This document contains information proprietary and confidential to
Mentor Graphics Corp., and is not for external distribution.
========================================================================

BridgePoint Project Analysis Note
Parameter Ordering

1. Abstract
-----------
Customers have been asking for parameter ordering for a long time. This note
describes adding this feature in a number of places.

2. History
----------

  final - i2932-050708-01

3. Document References
----------------------
[1] Bugzilla item 2932
    http://tucson.wv.mentorg.com/bugzilla/show_bug.cgi?id=2932
[2] UML Reference Manual ISBN 0-321-24562-8 pp 501 Term: 'ordering'
[3] BridgePoint Design Guide pp 198 'Parse Keyword'

4. Background
-------------
Attributes are currently the only things within the metamodel which support
arbitrary user ordering. The following other elements shall become user
orderable with this work:

- operation parameters
- function parameters
- bridge parameters
- signal parameters
- event parameters
- interface operation parameters
- operations (within a class)
- signals (within an interface)
- interface operations (within an interface)
- structure member
- enumerator

5. Analysis
-----------
The issue [1] suggests that the model pattern for Attributes (ordered by R103)
should be followed to meet this requirement. This is certainly a viable option,
but this is such an extensive list, that it may be more cost effective to build
some architectural support for this capability. This note will therefore
consider the following alternative architectural options; architectural ordering
by Parsed Keyword[3], formal tool support for UML {ordered} tagging[2]. Finally,
this note will consider a hybrid approach that combines an explicit association
together with a Parsed Keyword that calls it out.

Note: In all cases discussed below, any change in ordering shall cause
persistence of the relevant model element.

5.1 Explicit model based ordering

5.1.1 The existing support for ordering attributes is achieved by the following
metamodel features:

- Reflexive association R103 'Attribute succeeds Attribute'.
- Two operations of Attribute; 'moveUp' and 'moveDown'.
- Two cases in the Attribute.actionFilter() operation for 'can - move up' and
  'can - move down'.

5.1.2 Also the following eclipse specific data is required:

- Two object contributions in core/plugin.xml to trigger move up and move down
  with action filters. This is achieved by two CME (context menu entry) table
  entries in core/context_menu.pei.sql and two MEF (model element filter) table
  entries for the action filters (located in the same file).

5.1.3 In addition, in Model Class.get_compartment_text(), there is code that
traverses R103 to provide the attributes to the canvas in the specified order.

5.1.4 Finally, the tree node specification in ooaofooa_hierarchy.sql specifies
that Attributes are sorted based on R103 in the 'succeeds' direction.

5.1.5 The required behavior specified in 4. above can be provided by replicating
all of this design 'n' times, where 'n' is the number of elements specified in
4.

5.1.6 The metamodel changes will also require some simple data upgrade to place
the specified elements into an initial order (which will be the same as the 
order they are found in the model).

5.1.7 The informal diagrams do not currently attempt to keep in line with
attribute ordering changes. This work will follow this precedent, i.e. no
parameter ordering behavior is proposed for informal diagrams. If this behavior
is required, then additional work is needed to perform this synchronization,
including for formal attributes shown for 'Class Participant' and
'Class Instance Participant' elements found on Activity, Sequence and
Communication diagrams.

5.1.8 All model compilers will have to be changed to use the new ordering
association, although unmodified model compilers will continue to work,
outputting data based on the default order.

5.2 Architectural ordering
5.2.1 Parsed Keyword 'OrderedBy'
Using this approach, support for a new Parsed Keyword[3] will be added;
'OrderedBy:User'. Using this keyword, MC-Java shall generate code to support
handling element ordering directly. This new code shall cover both the data
ordering itself and the context menu action filter support. Move up and down
shall be triggered by object contributions generated by an extension to
create_core_plugin.arc which will scan the metamodel for 'OrderedBy' keywords
and generate the appropriate eclipse extensions.

5.2.2 Since the default behavior for the canvas, explorer trees, persistence and
generator mechanisms is to handle metamodel data in the order found in memory,
no changes are required for the canvas, explorer, verifier or model compilers 
using this approach. Model compilers shall see the elements appear in a .for 
each loop in the order specified at the UI. 

5.2.3 Informal diagrams would still need the changes described in 5.1.7 above if
their formal attribute and parameter displays are to be synchronized, since
their data is captured in separate metamodel instances. Consistent with section
5.1.7, parameter ordering behavior on informal diagrams is not proposed for this
job.

5.3 Add UML {ordered} tag to Builder capability
With this approach, the user visible behavior would be exactly the same as for
5.2, but instead of parsing for a Keyword to direct the code generation, the
Builder is enhanced to add an {ordered} tag to the association ends. This tag
shall be displayed at the association end on the canvas, next to the cardinality
notation. This is preferable to the keyword parse approach in 5.2 because it
clearly documents to the user that ordering is specified.

5.4 Explicit association with Parsed Keyword
5.4.1 In this alternative, the explicit reflexive associations described in
[5.1.1] are added by hand, but a parsed keyword in the class description
indicates to the architecture that the reflexive association specifies the
ordering. The architecture then directly generates the code to handle ordering,
so no operations like 'moveUp' or the action filters need be written explicitly.

5.4.2 Similarly, the context menu entries and handler actions are all generated
by the architecture.

5.4.3 The correct referentials for the selected ordering shall be persisted, so
that the model compilers shall be able to use the ordering data with the same
enhancements specified in [5.1.8].

5.4.4 An enhancement to this approach is to write the referential _and_ alter
the data element storage order. This way, unmodified model compilers can get
the benefit of ordered element output without modification, but architects have
access explicitly to the ordering data through the reflexive association.
Without element storage ordering, the other changes specified in 5.1 (i.e. apart
from the Move Up/Down and action filter changes) still need to be done.

6. Work Required
----------------
During discussions, an additional requirement was placed on the adopted
solution; the model compilers cannot rely on data order alone i.e. the
reflexive association must be explicitly provided to the model compilers.

Given this constraint, the perceived benefits of an architectural solution are
significantly reduced since the amount of saved work is reduced to removing
necessary operations and existing infrastructure entries.

It is therefore recommended that the approach described in 5.1 above is
followed. Of course, if the designer can see after one iteration that an obvious
path exists to implementing one of the architectural options with significantly
less effort the discretion is with them.

Assuming that 5.1 is followed, however, no additional description of the work
required is needed.

There is a suggestion that some refactoring of the moveUp, moveDown code will
yield common code (and consequently reduced maintenance in the future). However,
these operations are short, so maintenance benefits versus increased complexity
must be weighed carefully.

7. Acceptance Test
------------------
- Repeat the following tests for each of the model elements listed in section 4.

7.1 show context menu for a singleton element (only one under the parent)
_R MoveUp and MoveDown are both disabled.

7.2 show context menu for two elements
- element is at the top
_R Move Up is disabled.
- element is at the bottom
_R Move Down is disabled

7.3 test for three elements
- element is at the top
_R Move Up is disabled.
- element is at the bottom
_R Move Down is disabled
- element is in the middle
_R Both Move Up and Move Down are enabled.

7.4 select menu entry for two elements
- element is at the top, select Move Down
_R element moves to lower position.
- element is at the bottom, select Move Up
_R element moves to upper position

7.5 select menu entry for three elements
- element is at the top, select Move Down
_R element moves to middle position
- element is at the bottom, select Move Up
_R element moves to middle position
- element is in the middle, select Move Up
_R element moves to upper position
- element is in the middle, select Move Down
_R element moves to lower position

7.6 select menu entry for four or more elements
- element is in the middle, select Move Up
_R element moves up one position
- element is in the middle, select Move Down
_R element moves down one position

7.7 Create an archetype to traverse from the parent element to the selected
    model element
-  Using the new functionality described above, create a test model that has a
   different element order than the default (i.e. not the order in which the
   data is stored in the file).
-  Have the archetype print the element names in the order found by traversing
   across the new associations described in the note above.
_R The order of output follows the order found in the UI

7.8 Confirm that all canvas text reflects the ordering specified in the Model
   explorer

7.9 All exisiting Unit Tests pass (existing canvas expected results should _not_
    have to change).

End
---

$Log$
Revision 1.2  2009/01/01 23:13:01  rmulvey
Job:4060
Batch promotion of copyright changes from Review-i4060 and Review-i4060-01.

Revision 1.1.4.1  2008/12/31 16:10:04  rmulvey
Job:4060
This is a batch commit of 2009 copyright changes to branch Review-i4060.  This includes the
report that outlines all changes made (before/after for each line changed).  This report is found here: <cvs>/Documentation/internal/test_results/R2_1_2/i4060/update-copyright-results.txt.

Revision 1.1  2008/06/06 14:47:19  rmulvey
Job:3526
Archived the issues resolved during the R2_0_0 thru R2__0_2 releases into the Documentation/archive/20080606 folder.  Updated the Documentation/archive/20080606/README.tnt note accordingly.

Revision 1.3  2008/05/07 21:59:10  campbell
Job: 2932
Address review observations.

Revision 1.2  2008/04/24 21:44:39  jrwolfe
Job:2932
Fixed a few typos.

Revision 1.1  2008/04/24 19:58:36  campbell
Job: 2932
Introduced.

