========================================================================

File:      $RCSfile: dts0100696428.dnt,v $
Version:   $Revision: 1094 $
Modified:  $Date: 2011-06-14 12:33:49 -0700 (Tue, 14 Jun 2011) $

(c) Copyright 2007-2010 by Mentor Graphics Corp. All rights reserved.

========================================================================
This document contains information proprietary and confidential to
Mentor Graphics Corp., and is not for external distribution.
========================================================================

BridgePoint Project Design Note
Prevent files outside of the current model being modified and marked dirty

1. Abstract
-----------
Files outside of the current model being modified are marked dirty by the CVS
Team plugin. This note describes the cause and the fix.

2. History
----------

3. Document References
----------------------
[1] ClearQuest DEI dts0100696428 - Files outside of the model being modified are
marked dirty.

4. Background
-------------
When working on one model, the user is surprised to see model files outside of
the current model being marked as modified by the CVS Team plugin.

5. Analysis
-----------
5.1 Problem trap
The problem was trapped by setting a breakpoint in PersistableModelComponent in
the persist() method. A point was chosen after the component's parent path is
computed and a condition was set on the breakpoint such that halt would occur if
the parent path did not contain the name of Model being edited. The problem
was then recreated using the reproduction procedure in the issue.

The breakpoint was immediately hit. Unfortunately, this did not help much
because, by the time this breakpoint was hit, there was no record of which piece
of code made the model change which triggered the persistence.

Persistence is triggered at transaction end. At this time the transactionEnded()
method of the ComponentTransactionListener class is invoked. This iterates over
the very large set of model delta records produced by the last model operation.

Model deltas are created for every tiny change made to the model. They contain a
'before' and 'after' snapshot of the affected model element and are created
automatically by all code generated by MC-Java from the OAL code in the
metamodel. These deltas are used for multiple purposes, including (but not
limited to) rolling back changes when Undo and Redo are used. They are also used
by the persistence mechanism to determine whether a given block of model data
should be written to the file system (note that such a block of model data is
termed a 'persistence component', this is not to be confused in any way with a
UML component).

The delta that was current when the breakpoint is hit does indeed show that the
model being written had a modification made to it, so the persistence mechanism
is operating as designed.

5.2 Stack trace stamping
To further dig into the problem, a debugging only line was added to the class,
BaseModelDelta:

StackTraceElement[] stack = Thread.currentThread().getStackTrace();

BaseModelDelta is, as the name suggests, the super class for all model deltas.
What this debugging line does is to declare and initialize a stack trace field
inside every model delta. Because the initializer gets the stack trace for the
current thread, the model delta instance is branded at construction time with
the stack trace of whatever caused the delta to be created.

5.3 Results and analysis
Now, when a halt occurs at the originally set breakpoint in the persist() method
of PersistableModelComponent, looking back up the stack shows the invocation
inside the delta handler of ComponentTransactionListener's transactionEnded()
method as before. However this time, the model delta instances all show the
stack trace of the code that caused the delta to be created. Examination of
these stack traces show two sources for the model changes:

5.3.1 Data upgrade
As part of the deletion process, the policy is to clean up the parts of the
model as much as possible to remove references to elements being deleted. For
example, if a data type is deleted, attributes, arguments, function return
values etc. that refer to that data type are migrated back to a default value
(void for a return value and integer for everything else). In order for this to
happen, parts of the model database may have to be loaded in order to look for
such references.

Depending on the age of the model data, this loading may trigger data upgrade
behavior. Much data upgrade either calls into meta-model generated methods or
into methods generated by the architecture to get the upgrade work done. These
calls create deltas which are accumulated if a transaction is in progress. At
tool startup, no transaction is in progress, but for loading happening during a
delete operation, a transaction is most certainly present. Data upgrade, then,
causes deltas to be accumulated against a transaction and the persistence
mechanism sees the deltas and persists accordingly.

5.3.2 Graphics reconciler
In the cases investigated, it was noted that the graphics reconciler was
operating as designed. The Models folder has old models in it, and the data
upgrades can cause there to be inconsistencies between the model and its
graphics. The reconciler correctly kicks in to rectify the discrepancy.

5.4 Conclusion
It should be noted that both these sources of unexpected model changes are
happening because the models contain old data. Users working on recently created
models will not notice these problems.

5.4.1 Data upgrade
This process is in theory not subject to persistence, nor to Undo/Redo
requirements. It is therefore recommended that model delta collection be
disabled during data upgrade.

5.4.2 Graphics reconciler
The graphics reconcile process should also trigger neither persistence, nor be
subject to Undo/Redo, so the conclusion here is that it should also disable
model delta collection.

6. Design
---------
6.1 Data upgrade
There is no minimalist way to prevent deltas being created, this would require
many changes to MC-Java. However, it is quite straightforward to prevent the
deltas being collected by ensuring that the default model root instance has a
null activeTransaction instance. Two new methods are added to the ModelRoot
class. These are named disableDeltaCollection() and enableDeltaCollection().
The first caches the activeTransaction in a field called disabledTransaction and
then sets activeTransaction to null. The second restores the cached value to the
activeTransaction field.

Both methods check that delta collection is not currently already disabled (in
the case of disableDeltaCollection) and that delta collection is not already
active (in the case of enableDeltaCollection). If the preconditions are found to
be violated a java.lang.IllegalStateException is thrown with an appropriate
message and stack trace.

Note that, as discussed in section 5.3.1, it is possible for loading to occur
when no transaction is in progress. The new methods honor this by doing nothing
if the activeTransaction field is null.

The archetype file gen_import_java.inc is modified to call the disable and
enable delta collection methods introduced above. The calls are wrapped in a
try .. finally block so that delta collection is re-enabled, even in the
presence of an unforeseen data upgrade exception.

6.2 Graphics reconciliation
In the CavasTransactionListener class, in the method runReconciler, the call to
AutoReconciliationSpecification_c.Reconcile operation is wrapped in calls to the
disable and enable delta collection methods. Again, a try .. finally block
guards against delta collection being turned off permanently by an exception.
Note that we disable delta collection here only for the graphics; any meta model
changes should be persisted.

7. Design Comments
------------------
A couple of performance enhancements were noticed and incorporated into this
work.

7.1 OoaofooaBase 
7.1.1 getProjectNameFromModelRootId
This method, is modified to not perform a String split until it is actually
needed. Although this is a tiny gain, the method is called very frequently. 

7.1.2 updateId
This method is modified to check to see if the old and new ids are actually
different before removing and replacing the id in the instance map. Again a
small enhancement, but this method is called very frequently.

7.2 InstanceList
The getGlobal method is modified to not search globally for long based ids,
which is inherently unsafe. A convenience method is added to identify long based
ids. Also, when searching for a SystemModel instance, getGlobal now restricts
the search to the default root.

7.3 NonRootModelElement
The updateInstanceKey method has the test for old and new key equivalence
modified so that identical keys are properly detected. This reduces the
frequency of calls to updateKey which can take a long time to run for large
workspaces.

7.4 Dimensions data upgrade
This data upgrade was being done using a different idiom than other data
upgrades which meant that its code was scattered through create<KeyLetter>
operations generated by import_functions.inc. This upgrade mechanism was
reworked to follow the standard upgrade idiom and the generated upgrade code
was removed.

8. Work Required
----------------
Fully discussed in the design section.

9. Unit Test
------------
A new test is added to IOMdl2 test suite. DataUpgradeCreatesNoDeltasTest tests
the fix by deleting the Subsystem element exactly as described in reproduction
procedure in the issue[1].  A variety of models from the CVS Models project are
loaded to check that unwanted file persistence is not taking place. The test
class registers a transaction listener that examines the set of deltas produced
by the deletion to ensure that no model elements outside the model being changed
by the deletion appear in the set.

To see the test fail, simply comment out the calls to disableDeltaCollection in
ImportModelComponent.finishLoad() (at line 1403 in my build).

In addition, all existing JUnit tests must pass.

End
---

$Log: dts0100696428.dnt,v $
Revision 1.4  2010/08/05 15:05:27  campbell
Job: dts0100696428
Address review observations.

Revision 1.3  2010/08/05 13:43:03  campbell
Job: dts0100696428
Added a comment about reconciling meta model changes.

Revision 1.2  2010/08/05 10:28:29  campbell
Job: dts0100696428
Ready for review.

Revision 1.1  2010/08/03 10:09:42  campbell
Job: dts0100696428
Introduced.

