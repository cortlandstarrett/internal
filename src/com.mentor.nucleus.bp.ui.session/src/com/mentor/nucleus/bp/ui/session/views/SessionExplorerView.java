package com.mentor.nucleus.bp.ui.session.views;
//======================================================================
//
// File: com/mentor/nucleus/bp/ui/session/views/SessionExplorerView.java
//
// WARNING:      Do not edit this generated file
// Generated by: arc/create_SessionExplorer_view.inc
// Version:      $Revision$
//
// (c) Copyright 2006-2014 by Mentor Graphics Corp. All rights reserved.
//
//=======================================================================
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the
// License for the specific language governing permissions and limitations under
// the License.
//=======================================================================
//
// This class is the main entry point for the SessionExplorerView View.
// It is responsible for building the presentation to the user and
// for provideing the interface to the Eclipse infrastructure.
//
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Iterator;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IResourceChangeEvent;
import org.eclipse.core.resources.IResourceChangeListener;
import org.eclipse.core.resources.IResourceDelta;
import org.eclipse.core.resources.IResourceDeltaVisitor;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IConfigurationElement;
import org.eclipse.core.runtime.IExtension;
import org.eclipse.core.runtime.IExtensionPoint;
import org.eclipse.core.runtime.IExtensionRegistry;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.Platform;
import org.eclipse.jface.action.Action;
import org.eclipse.jface.action.GroupMarker;
import org.eclipse.jface.action.IMenuListener;
import org.eclipse.jface.action.IMenuManager;
import org.eclipse.jface.action.IToolBarManager;
import org.eclipse.jface.action.MenuManager;
import org.eclipse.jface.action.Separator;
import org.eclipse.jface.viewers.DecoratingLabelProvider;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.ILabelProvider;
import org.eclipse.jface.viewers.IOpenListener;
import org.eclipse.jface.viewers.ISelectionChangedListener;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.viewers.OpenEvent;
import org.eclipse.jface.viewers.SelectionChangedEvent;
import org.eclipse.jface.viewers.TreeViewer;
import org.eclipse.jface.viewers.Viewer;
import org.eclipse.jface.viewers.ViewerFilter;
import org.eclipse.swt.SWT;
import org.eclipse.swt.layout.FillLayout;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Control;
import org.eclipse.swt.widgets.Menu;
import org.eclipse.ui.IActionBars;
import org.eclipse.ui.IEditorInput;
import org.eclipse.ui.IEditorPart;
import org.eclipse.ui.IPartListener;
import org.eclipse.ui.ISelectionListener;
import org.eclipse.ui.IWorkbenchPart;
import org.eclipse.ui.IWorkbenchActionConstants;
import org.eclipse.ui.PartInitException;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.actions.ActionFactory;
import org.eclipse.ui.actions.ExportResourcesAction;
import org.eclipse.ui.actions.ImportResourcesAction;
import org.eclipse.ui.actions.NewWizardMenu;
import org.eclipse.ui.actions.RefreshAction;
import org.eclipse.ui.part.ViewPart;
import org.eclipse.ui.views.framelist.BackAction;
import org.eclipse.ui.views.framelist.ForwardAction;
import org.eclipse.ui.views.framelist.FrameList;
import org.eclipse.ui.views.framelist.TreeViewerFrameSource;
import org.eclipse.ui.views.framelist.UpAction;
import org.eclipse.ui.views.properties.IPropertySheetPage;
import org.eclipse.ui.views.properties.PropertySheetPage;
import org.osgi.framework.Bundle;

import com.mentor.nucleus.bp.core.*;
import com.mentor.nucleus.bp.core.common.*;
import com.mentor.nucleus.bp.core.ui.DeleteAction;
import com.mentor.nucleus.bp.core.ui.RenameAction;
import com.mentor.nucleus.bp.core.ui.Selection;
import com.mentor.nucleus.bp.core.util.EditorUtil;
import com.mentor.nucleus.bp.core.util.UIUtil;

import com.mentor.nucleus.bp.ui.properties.BridgepointPropertySheetPage;
import com.mentor.nucleus.bp.ui.properties.ModelPropertySourceProvider;
import com.mentor.nucleus.bp.ui.session.ISessionExplorerHelpContextIds;
import com.mentor.nucleus.bp.ui.session.SessionExplorerContentProvider;
import com.mentor.nucleus.bp.ui.session.SessionExplorerFiltersContentProvider;
import com.mentor.nucleus.bp.ui.session.SessionExplorerLabelProvider;
import com.mentor.nucleus.bp.ui.session.SessionExplorerTreeViewer;
import com.mentor.nucleus.bp.ui.session.actions.FilterSelectionAction;

/**
 * SessionExplorerView allows the user to navigate the BridgePoint
 * metamodel. It provides a tree view analogous to that provided
 * by the Java Package Explorer.
 * 
 * @see ViewPart
 */
public class SessionExplorerView extends ViewPart {
	private static final String COLLAPSE = "Collapse All";
	private static final String OPEN = "open";
	private static final String HIDE_STATICS = "Hide Static Members";
	private static final String HIDE_SYSTEM = "Hide System";
	private static final String HIDE_DOMAINS = "Hide Domains";
	private static final String HIDE_FUNCTIONS = "Hide Functions";
	private static final String HIDE_CLASSES = "Hide Classes";
	private static final String HIDE_INSTANCES = "Hide Instances";
	private static final String HIDE_VALUES = "Hide Values";
	private static final String HIDE_PENDINGEVENTS = "Hide PendingEvents";
	private static final String HIDE_CLASS_STATES = "Hide Class States";
	private static final String HIDE_STATES = "Hide States";
	private static final String HIDE_RUNTIMEVALUES = "Hide RuntimeValues";
	private static final String HIDE_COMPONENTS = "Hide Components";
	private static final String HIDE_COMPONENT_INSTANCES = "Hide Component Instances";
	private static final String HIDE_PORTS = "Hide Ports";
	private static final String HIDE_PROVISIONS = "Hide Provisions";
	private static final String HIDE_REQUIREMENTS = "Hide Requirements";
	private static final String HIDE_PROVIDED_OPERATIONS = "Hide Provided Operations";
	private static final String HIDE_PROVIDED_SIGNALS = "Hide Provided Signals";
	private static final String HIDE_REQUIRED_OPERATIONS = "Hide Required Operations";
	private static final String HIDE_REQUIRED_SIGNALS = "Hide Required Signals";
	private static final String HIDE_PARAMETERS = "Hide Parameters";
	private static final String HIDE_OPERATIONS = "Hide Operations";
	private static final String HIDE_COMPONENT_REFERENCES = "Hide Component References";
	private static final String HIDE_COMPONENT_REFERENCE_INSTANCES = "Hide Component Reference Instances";
	private static final String HIDE_ASSOCIATIONS = "Hide Associations";
	private static final String HIDE_FUNCTION_PACKAGES = "Hide Function Packages";
	private static final String HIDE_FUNCTION_PARAMETERS = "Hide Function Parameters";
	private static final String HIDE_PACKAGES = "Hide Packages";
	private FrameList frames;
	protected SessionExplorerTreeViewer treeViewer;
	protected SessionExplorerLabelProvider labelProvider;
	protected MenuManager menuManager;
	protected Action collapseAll, linkWithEditor;
	protected Action back, fwd, up;
	protected Action cut, copy, paste;
	protected Action open, delete, rename;
	protected Action fileImport, fileExport;
	protected Action treeRefresh;
	protected Action hideStatics;
	protected Action hideSystem, hideDomains, hideFunctions, hideClasses,
			hideInstances, hideValues, hidePendingEvents, hideClassStates,
			hideStates, hideRuntimeValues, hideComponents,
			hideComponentInstances, hidePorts, hideProvisions,
			hideRequirements, hideProvidedOperations, hideProvidedSignals,
			hideRequiredOperations, hideRequiredSignals, hideParameters,
			hideOperations, hideComponentReferences,
			hideComponentReferenceInstances, hideAssociations,
			hideFunctionPackages, hideFunctionParameters, hidePackages;
	protected FilterSelectionAction filters;
	protected ViewerFilter filterStatics;
	protected ViewerFilter filterSystem, filterDomains, filterFunctions,
			filterClasses, filterInstances, filterValues, filterPendingEvents,
			filterClassStates, filterStates, filterRuntimeValues,
			filterComponents, filterComponentInstances, filterPorts,
			filterProvisions, filterRequirements, filterProvidedOperations,
			filterProvidedSignals, filterRequiredOperations,
			filterRequiredSignals, filterParameters, filterOperations,
			filterComponentReferences, filterComponentReferenceInstances,
			filterAssociations, filterFunctionPackages,
			filterFunctionParameters, filterPackages;

	private IModelChangeListener m_modelChangeListener;
	private ITransactionListener m_transactionListener;
	private ISelectionChangedListener m_selChangedListener;
	private IPartListener m_partListener;
	private static SessionExplorerView instance = null;

	private static Selection selection = Selection.getInstance();

	/**
	 * The constructor.
	 */
	public SessionExplorerView() {
		instance = this;
	}
	/**
	 * Returns the tree viewer for the SessionExplorerView window
	 */
	public SessionExplorerTreeViewer getTreeViewer() {
		return treeViewer;
	}

	public static SessionExplorerView instance() {
		if (instance == null) {
			new SessionExplorerView();
		}
		return instance;
	}
	/*
	 * @see IWorkbenchPart#createPartControl(Composite)
	 */
	public void createPartControl(Composite parent) {
		// Create the view's layout
		FillLayout layout = new FillLayout();
		parent.setLayout(layout);
		treeViewer = new SessionExplorerTreeViewer(parent);
		treeViewer.setContentProvider(new SessionExplorerContentProvider());
		labelProvider = new SessionExplorerLabelProvider();
		treeViewer.setLabelProvider(labelProvider);
		treeViewer.setUseHashlookup(true);
		// Create menu, toolbar and filters.
		createActions();
		createMenus();
		createToolbar();
		createFilters();
		hookListeners();
		initLabelProvider(treeViewer);
		treeViewer.setInput(Ooaofooa.getDefaultInstance());
		// disable until non-instance data is not removable
		//
		// getViewSite().getActionBars().setGlobalActionHandler(
		//   ActionFactory.DELETE.getId(),
		//   delete);
		// getViewSite().getActionBars().setGlobalActionHandler(
		//   ActionFactory.RENAME.getId(),
		//   rename);
		getViewSite().getActionBars().setGlobalActionHandler(
				ActionFactory.COPY.getId(), copy);
		getViewSite().getActionBars().setGlobalActionHandler(
				ActionFactory.CUT.getId(), cut);
		getViewSite().getActionBars().setGlobalActionHandler(
				ActionFactory.PASTE.getId(), paste);
		// Set help for the view 
		PlatformUI
				.getWorkbench()
				.getHelpSystem()
				.setHelp(treeViewer.getControl(),
						ISessionExplorerHelpContextIds.SessionExplorerViewId);
	}
	/**
	 * Hook up all the listeners needed by SessionExplorerView
	 */
	protected void hookListeners() {
		m_partListener = new IPartListener() {

			public void partActivated(IWorkbenchPart part) {
				// update the system selection if the part
				// activated is an instance of this class
				if (part instanceof SessionExplorerView)
						  if(!getTreeViewer().getTree().isDisposed()) {
						// if link with editor is set the selection will
						// already by up to date, otherwise set the current
						// selection to that of this viewers
						if (!linkWithEditor.isChecked()) {
							selection.setSelection(getTreeViewer().getSelection());
							}
						}
					}

			public void partDeactivated(IWorkbenchPart part) {}

			public void partBroughtToTop(IWorkbenchPart part) {}

			public void partClosed(IWorkbenchPart part) {}

			public void partOpened(IWorkbenchPart part) {}

			};
		getSite().getPage().addPartListener(m_partListener);

    treeViewer.addSelectionChangedListener(new ISelectionChangedListener() {
      public void selectionChanged(SelectionChangedEvent event) {
        // Transfer the selection to the model
        selection.setSelection(event.getSelection());
      }
    });
    m_selChangedListener = new ISelectionChangedListener() {
      public void selectionChanged(SelectionChangedEvent event) {
        if (!getTreeViewer().getTree().isDisposed()) {
          if (linkWithEditor.isChecked()){
            // transfer the selection to the tree, but avoid having the tree 
            // viewer report its selection change to its listeners, as if what the 
            // model is reporting as selected is not contained in the tree
            // (such as when a connector is selected), we don't want the
            // tree's newly empty selection being propagated back to the model 
            // by the treeview-listener, above; see issue 453 for more context
            IStructuredSelection selection = (IStructuredSelection)event.getSelection();
            setTreeSelection(getTreeViewer(), selection);
          }
        }
      }
    };
    selection.addSelectionChangedListener(m_selChangedListener);
    m_modelChangeListener = new ModelChangeAdapter() {
		public void modelElementLoaded(ModelChangedEvent event) {
			if (!getTreeViewer().getTree().isDisposed()) {
				Object modelElement = event.getModelElement();
	
				SessionExplorerTreeViewer viewer = getTreeViewer();
				Object parent = ((SessionExplorerContentProvider) viewer.getContentProvider()).getParent(modelElement);
				UIUtil.refreshViewer(viewer, parent);
			}
		}
		public void modelElementUnloaded(ModelChangedEvent event) {
			if (!getTreeViewer().getTree().isDisposed()) {
				Object modelElement = event.getModelElement();
	
				SessionExplorerTreeViewer viewer = getTreeViewer();
				Object parent = ((SessionExplorerContentProvider) viewer.getContentProvider()).getParent(modelElement);
				UIUtil.refreshViewer(viewer, parent);
			}
		}
    };
	m_transactionListener = new ITransactionListener() {
			@Override
			public void transactionCancelled(Transaction transaction) {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void transactionEnded(Transaction transaction) {
				PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable() {
					
					@Override
					public void run() {
						getTreeViewer().refresh();	
					}
				});
			}

			@Override
			public void transactionStarted(Transaction transaction) {
				// TODO Auto-generated method stub
				
			}
		};
	TransactionManager.getSingleton().addTransactionListener(m_transactionListener);
    treeViewer.addOpenListener(new IOpenListener() {
      public void open(OpenEvent event) {
        handleOpen();
      }
    });
  }
	private static void setTreeSelection(SessionExplorerTreeViewer tv,
			IStructuredSelection sel) {
		tv.setSelectionToWidget(sel, true);

		// scroll to reveal all elements of the new selection
		for (Iterator iterator = sel.iterator(); iterator.hasNext();) {
			Object element = iterator.next();
			tv.reveal(element);
		}
	}
	public static final boolean classInTree(Object o) {
		if (o instanceof SystemModel_c)
			return true;
		if (o instanceof Domain_c)
			return true;
		if (o instanceof Function_c)
			return true;
		if (o instanceof Instance_c)
			return true;
		if (o instanceof AttributeValue_c)
			return true;
		if (o instanceof PendingEvent_c)
			return true;
		if (o instanceof StateMachineState_c)
			return true;
		if (o instanceof Component_c)
			return true;
		if (o instanceof ComponentInstance_c)
			return true;
		if (o instanceof Port_c)
			return true;
		if (o instanceof Provision_c)
			return true;
		if (o instanceof Requirement_c)
			return true;
		if (o instanceof ProvidedOperation_c)
			return true;
		if (o instanceof ProvidedSignal_c)
			return true;
		if (o instanceof RequiredOperation_c)
			return true;
		if (o instanceof RequiredSignal_c)
			return true;
		if (o instanceof PropertyParameter_c)
			return true;
		if (o instanceof Operation_c)
			return true;
		if (o instanceof ComponentReference_c)
			return true;
		if (o instanceof LinkParticipation_c)
			return true;
		if (o instanceof FunctionPackage_c)
			return true;
		if (o instanceof FunctionParameter_c)
			return true;
		if (o instanceof Package_c)
			return true;
		if (o instanceof ModelClass_c)
			return true;
		if (o instanceof ComponentPackage_c)
			return true;
		if (o instanceof PackageableElement_c)
			return true;
		if (o instanceof InterfaceReference_c)
			return true;
		if (o instanceof ProvidedExecutableProperty_c)
			return true;
		if (o instanceof RequiredExecutableProperty_c)
			return true;
		if (o instanceof ExecutableProperty_c)
			return true;
		if (o instanceof Link_c)
			return true;
		if (o instanceof DomainAsComponent_c)
			return true;
		if (o instanceof FunctionPackageInPackage_c)
			return true;
		if (o instanceof ComponentInstanceContainer_c)
			return true;
		if (o instanceof ReferentialAttribute_c)
			return true;
		if (o instanceof AttributeReferenceInClass_c)
			return true;
		return false;
	}
	/**
	 * Create the Actions provided by SessionExplorerView
	 */
	protected void createActions() {
		frames = new FrameList(new TreeViewerFrameSource(getTreeViewer()));
		back = new BackAction(frames) {
			public void run() {
			}
		};
		fwd = new ForwardAction(frames) {
			public void run() {
			}
		};
		up = new UpAction(frames) {
			public void run() {
			}
		};
		collapseAll = new Action(COLLAPSE) {
			public void run() {
				getTreeViewer().collapseAll();
			}
		};
		collapseAll.setToolTipText(COLLAPSE);
		collapseAll.setImageDescriptor(CorePlugin
				.getImageDescriptor("collapseall.gif")); //$NON-NLS-1$
		PlatformUI
				.getWorkbench()
				.getHelpSystem()
				.setHelp(collapseAll,
						ISessionExplorerHelpContextIds.COLLAPSE_ALL_ACTION);
		linkWithEditor = new Action(IWorkbenchActionConstants.SHOW_IN) {
			public void run() {
				IStructuredSelection selection = (IStructuredSelection) Selection
						.getInstance().getSelection();
				getTreeViewer().setSelection(selection);
				for (Iterator iterator = selection.iterator(); iterator
						.hasNext();) {
					Object element = iterator.next();
					getTreeViewer().reveal(element);
				}
			}
		};
		linkWithEditor.setChecked(false);
		linkWithEditor.setText("Link With Editor");
		linkWithEditor.setToolTipText("Link with Editor");
		linkWithEditor.setImageDescriptor(CorePlugin
				.getImageDescriptor("synced.gif")); //$NON-NLS-1$
		// 'New' is provided as a sub-menu only. See 'createMenus'
		open = new Action(OPEN) {
			public void run() {
				handleOpen();
			}
		};
		open.setText("Open");
		open.setToolTipText("Open this model Element");
		// 'Open With' is provided as a sub-menu only. See 'createMenus'
		cut = new Action(ActionFactory.CUT.getId()) {
			public void run() {
			}
		};
		cut.setText("Cut");
		cut.setToolTipText("Cut this model Element to the clipboard");
		cut.setImageDescriptor(CorePlugin.getImageDescriptor("cut_edit.gif")); //$NON-NLS-1$
		cut.setEnabled(false); // Retargetable Actions work removes this line
		copy = new Action(ActionFactory.COPY.getId()) {
			public void run() {
			}
		};
		copy.setText("Copy");
		copy.setToolTipText("Copy this model Element to the clipboard");
		copy.setImageDescriptor(CorePlugin.getImageDescriptor("copy_edit.gif")); //$NON-NLS-1$
		copy.setEnabled(false); // Retargetable Actions work removes this line
		paste = new Action(ActionFactory.PASTE.getId()) {
			public void run() {
			}
		};
		paste.setText("Paste");
		paste.setToolTipText("Paste from the clipboard");
		paste.setImageDescriptor(CorePlugin
				.getImageDescriptor("paste_edit.gif")); //$NON-NLS-1$
		paste.setEnabled(false); // Retargetable Actions work removes this line
		//
		// Delete and Rename are retargetable actions defined by core.
		//
		delete = CorePlugin.getDeleteAction();
		rename = CorePlugin.getRenameAction(treeViewer);
		//
		fileImport = new Action(ActionFactory.IMPORT.getId()) {
			public void run() {
				ImportResourcesAction ira = new ImportResourcesAction(
						CorePlugin.getDefault().getWorkbench()
								.getActiveWorkbenchWindow());
				ira.run();
			}
		};
		fileImport.setText("Import...");
		fileImport.setToolTipText("Import a BridgePoint file");
		fileImport.setImageDescriptor(CorePlugin
				.getImageDescriptor("import_wiz.gif")); //$NON-NLS-1$
		fileExport = new Action(ActionFactory.EXPORT.getId()) {
			public void run() {
				ExportResourcesAction era = new ExportResourcesAction(
						CorePlugin.getDefault().getWorkbench()
								.getActiveWorkbenchWindow());
				era.run();
			}
		};
		fileExport.setText("Export...");
		fileExport.setToolTipText("Export a BridgePoint file");
		fileExport.setImageDescriptor(CorePlugin
				.getImageDescriptor("export_wiz.gif")); //$NON-NLS-1$
		hideStatics = new Action(HIDE_STATICS) {
			public void run() {
				updateFilter(hideStatics);
			}
		};
		treeRefresh = new Action(ActionFactory.REFRESH.getId()) {
			public void run() {
				RefreshAction ra = new RefreshAction(CorePlugin.getDefault()
						.getWorkbench().getActiveWorkbenchWindow().getShell());
				ra.run();
				getTreeViewer().refresh();
			}
		};
		treeRefresh.setText("Refresh");
		treeRefresh.setToolTipText("Refresh the tree");
		treeRefresh.setImageDescriptor(CorePlugin
				.getImageDescriptor("refresh.gif")); //$NON-NLS-1$
		treeRefresh.setAccelerator(SWT.F5);
		treeRefresh.setActionDefinitionId("org.eclipse.ui.file.refresh"); //$NON-NLS-1$
		getSite().getKeyBindingService().registerAction(treeRefresh);

		hideStatics.setChecked(false);
		hideStatics.setToolTipText(HIDE_STATICS);
		hideSystem = new Action(HIDE_SYSTEM) {
			public void run() {
				updateFilter(hideSystem);
			}
		};
		hideSystem.setChecked(false);
		hideSystem.setToolTipText(HIDE_SYSTEM);
		hideDomains = new Action(HIDE_DOMAINS) {
			public void run() {
				updateFilter(hideDomains);
			}
		};
		hideDomains.setChecked(false);
		hideDomains.setToolTipText(HIDE_DOMAINS);
		hideFunctions = new Action(HIDE_FUNCTIONS) {
			public void run() {
				updateFilter(hideFunctions);
			}
		};
		hideFunctions.setChecked(false);
		hideFunctions.setToolTipText(HIDE_FUNCTIONS);
		hideClasses = new Action(HIDE_CLASSES) {
			public void run() {
				updateFilter(hideClasses);
			}
		};
		hideClasses.setChecked(false);
		hideClasses.setToolTipText(HIDE_CLASSES);
		hideInstances = new Action(HIDE_INSTANCES) {
			public void run() {
				updateFilter(hideInstances);
			}
		};
		hideInstances.setChecked(false);
		hideInstances.setToolTipText(HIDE_INSTANCES);
		hideValues = new Action(HIDE_VALUES) {
			public void run() {
				updateFilter(hideValues);
			}
		};
		hideValues.setChecked(false);
		hideValues.setToolTipText(HIDE_VALUES);
		hidePendingEvents = new Action(HIDE_PENDINGEVENTS) {
			public void run() {
				updateFilter(hidePendingEvents);
			}
		};
		hidePendingEvents.setChecked(false);
		hidePendingEvents.setToolTipText(HIDE_PENDINGEVENTS);
		hideClassStates = new Action(HIDE_CLASS_STATES) {
			public void run() {
				updateFilter(hideClassStates);
			}
		};
		hideClassStates.setChecked(false);
		hideClassStates.setToolTipText(HIDE_CLASS_STATES);
		hideStates = new Action(HIDE_STATES) {
			public void run() {
				updateFilter(hideStates);
			}
		};
		hideStates.setChecked(false);
		hideStates.setToolTipText(HIDE_STATES);
		hideRuntimeValues = new Action(HIDE_RUNTIMEVALUES) {
			public void run() {
				updateFilter(hideRuntimeValues);
			}
		};
		hideRuntimeValues.setChecked(false);
		hideRuntimeValues.setToolTipText(HIDE_RUNTIMEVALUES);
		hideComponents = new Action(HIDE_COMPONENTS) {
			public void run() {
				updateFilter(hideComponents);
			}
		};
		hideComponents.setChecked(false);
		hideComponents.setToolTipText(HIDE_COMPONENTS);
		hideComponentInstances = new Action(HIDE_COMPONENT_INSTANCES) {
			public void run() {
				updateFilter(hideComponentInstances);
			}
		};
		hideComponentInstances.setChecked(false);
		hideComponentInstances.setToolTipText(HIDE_COMPONENT_INSTANCES);
		hidePorts = new Action(HIDE_PORTS) {
			public void run() {
				updateFilter(hidePorts);
			}
		};
		hidePorts.setChecked(false);
		hidePorts.setToolTipText(HIDE_PORTS);
		hideProvisions = new Action(HIDE_PROVISIONS) {
			public void run() {
				updateFilter(hideProvisions);
			}
		};
		hideProvisions.setChecked(false);
		hideProvisions.setToolTipText(HIDE_PROVISIONS);
		hideRequirements = new Action(HIDE_REQUIREMENTS) {
			public void run() {
				updateFilter(hideRequirements);
			}
		};
		hideRequirements.setChecked(false);
		hideRequirements.setToolTipText(HIDE_REQUIREMENTS);
		hideProvidedOperations = new Action(HIDE_PROVIDED_OPERATIONS) {
			public void run() {
				updateFilter(hideProvidedOperations);
			}
		};
		hideProvidedOperations.setChecked(false);
		hideProvidedOperations.setToolTipText(HIDE_PROVIDED_OPERATIONS);
		hideProvidedSignals = new Action(HIDE_PROVIDED_SIGNALS) {
			public void run() {
				updateFilter(hideProvidedSignals);
			}
		};
		hideProvidedSignals.setChecked(false);
		hideProvidedSignals.setToolTipText(HIDE_PROVIDED_SIGNALS);
		hideRequiredOperations = new Action(HIDE_REQUIRED_OPERATIONS) {
			public void run() {
				updateFilter(hideRequiredOperations);
			}
		};
		hideRequiredOperations.setChecked(false);
		hideRequiredOperations.setToolTipText(HIDE_REQUIRED_OPERATIONS);
		hideRequiredSignals = new Action(HIDE_REQUIRED_SIGNALS) {
			public void run() {
				updateFilter(hideRequiredSignals);
			}
		};
		hideRequiredSignals.setChecked(false);
		hideRequiredSignals.setToolTipText(HIDE_REQUIRED_SIGNALS);
		hideParameters = new Action(HIDE_PARAMETERS) {
			public void run() {
				updateFilter(hideParameters);
			}
		};
		hideParameters.setChecked(false);
		hideParameters.setToolTipText(HIDE_PARAMETERS);
		hideOperations = new Action(HIDE_OPERATIONS) {
			public void run() {
				updateFilter(hideOperations);
			}
		};
		hideOperations.setChecked(false);
		hideOperations.setToolTipText(HIDE_OPERATIONS);
		hideComponentReferences = new Action(HIDE_COMPONENT_REFERENCES) {
			public void run() {
				updateFilter(hideComponentReferences);
			}
		};
		hideComponentReferences.setChecked(false);
		hideComponentReferences.setToolTipText(HIDE_COMPONENT_REFERENCES);
		hideComponentReferenceInstances = new Action(
				HIDE_COMPONENT_REFERENCE_INSTANCES) {
			public void run() {
				updateFilter(hideComponentReferenceInstances);
			}
		};
		hideComponentReferenceInstances.setChecked(false);
		hideComponentReferenceInstances
				.setToolTipText(HIDE_COMPONENT_REFERENCE_INSTANCES);
		hideAssociations = new Action(HIDE_ASSOCIATIONS) {
			public void run() {
				updateFilter(hideAssociations);
			}
		};
		hideAssociations.setChecked(false);
		hideAssociations.setToolTipText(HIDE_ASSOCIATIONS);
		hideFunctionPackages = new Action(HIDE_FUNCTION_PACKAGES) {
			public void run() {
				updateFilter(hideFunctionPackages);
			}
		};
		hideFunctionPackages.setChecked(false);
		hideFunctionPackages.setToolTipText(HIDE_FUNCTION_PACKAGES);
		hideFunctionParameters = new Action(HIDE_FUNCTION_PARAMETERS) {
			public void run() {
				updateFilter(hideFunctionParameters);
			}
		};
		hideFunctionParameters.setChecked(false);
		hideFunctionParameters.setToolTipText(HIDE_FUNCTION_PARAMETERS);
		hidePackages = new Action(HIDE_PACKAGES) {
			public void run() {
				updateFilter(hidePackages);
			}
		};
		hidePackages.setChecked(false);
		hidePackages.setToolTipText(HIDE_PACKAGES);
		filters = new FilterSelectionAction(this, "Filters...");
		filters.setImageDescriptor(CorePlugin
				.getImageDescriptor("filter_ps.gif")); //$NON-NLS-1$
	}
	/**
	 * Create the menus for the SessionExplorerView
	 */
	protected void createMenus() {
		// Context Menu
		MenuManager menuManager = new MenuManager("#PopupMenu"); //$NON-NLS-1$
		menuManager.setRemoveAllWhenShown(true);
		final MenuManager createMenuManager = new MenuManager(
				"Ne&w", "com.mentor.nucleus.bp.ui.newroot"); //$NON-NLS-2$
		final MenuManager openMenuManager = new MenuManager(
				"Open Wit&h", "com.mentor.nucleus.bp.ui.openroot"); //$NON-NLS-2$
		final MenuManager classesMenu = new MenuManager(
				"Classes", "com.mentor.nucleus.bp.ui.classroot"); //$NON-NLS-2$
		final MenuManager componentsMenu = new MenuManager(
				"Components", "com.mentor.nucleus.bp.ui.componentroot"); //$NON-NLS-2$
		final MenuManager externalMenu = new MenuManager(
				"External", "com.mentor.nucleus.bp.ui.externalroot"); //$NON-NLS-2$
		final MenuManager interactionMenu = new MenuManager(
				"Interaction", "com.mentor.nucleus.bp.ui.interactionroot");//$NON-NLS-2$
		final MenuManager activityMenu = new MenuManager(
				"Activity", "com.mentor.nucleus.bp.ui.activityroot"); //$NON-NLS-2$
		final MenuManager typesMenu = new MenuManager(
				"Types", "com.mentor.nucleus.bp.ui.typeroot"); //$NON-NLS-2$
		final MenuManager useCaseMenu = new MenuManager(
				"Usecase", "com.mentor.nucleus.bp.ui.usecaseroot"); //$NON-NLS-2$

		menuManager.addMenuListener(new IMenuListener() {
			public void menuAboutToShow(IMenuManager mgr) {
				mgr.add(createMenuManager);
				createMenuManager.removeAll();
				createMenuManager.add(new GroupMarker(
						"com.mentor.nucleus.bp.ui.newmenu")); //$NON-NLS-1$

				createMenuManager.add(activityMenu);
				activityMenu.removeAll();
				activityMenu.add(new GroupMarker(
						"com.mentor.nucleus.bp.ui.newactivitymenu"));

				createMenuManager.add(classesMenu);
				classesMenu.removeAll();
				classesMenu.add(new GroupMarker(
						"com.mentor.nucleus.bp.ui.newclassmenu"));

				createMenuManager.add(componentsMenu);
				componentsMenu.removeAll();
				componentsMenu.add(new GroupMarker(
						"com.mentor.nucleus.bp.ui.newcomponentmenu"));

				createMenuManager.add(externalMenu);
				externalMenu.removeAll();
				externalMenu.add(new GroupMarker(
						"com.mentor.nucleus.bp.ui.newexternalmenu"));

				createMenuManager.add(interactionMenu);
				interactionMenu.removeAll();
				interactionMenu.add(new GroupMarker(
						"com.mentor.nucleus.bp.ui.newinteractionmenu"));

				createMenuManager.add(typesMenu);
				typesMenu.removeAll();
				typesMenu.add(new GroupMarker(
						"com.mentor.nucleus.bp.ui.newtypemenu"));

				createMenuManager.add(useCaseMenu);
				useCaseMenu.removeAll();
				useCaseMenu.add(new GroupMarker(
						"com.mentor.nucleus.bp.ui.newusecasemenu"));

				createMenuManager.add(new NewWizardMenu(getSite()
						.getWorkbenchWindow()));
				mgr.add(open);
				mgr.add(openMenuManager);
				openMenuManager.removeAll();
				openMenuManager.add(new GroupMarker(
						"com.mentor.nucleus.bp.ui.openmenu")); //$NON-NLS-1$
				mgr.add(new Separator(
						"com.mentor.nucleus.bp.ui.context-internal")); //$NON-NLS-1$
				mgr.add(new Separator(
						"com.mentor.nucleus.bp.ui.context-internal-end")); //$NON-NLS-1$
				mgr.add(cut);
				mgr.add(copy);
				mgr.add(paste);
				//  disable until non-instance related data is not removable
				//
				//  delete.setEnabled(DeleteAction.canDeleteAction());
				//  mgr.add(delete);
				//  rename.setEnabled(RenameAction.canRenameAction());
				//  mgr.add(rename);
				mgr.add(new Separator());
				mgr.add(fileImport);
				mgr.add(fileExport);
				mgr.add(new Separator());
				mgr.add(treeRefresh);
				// If this is omitted, the platform complains because
				// it can't allow third party plug-ins to extend the menu
				// This is important for those who wish to use change
				// management plugins because Team menu items are added here.
				mgr.add(new Separator(IWorkbenchActionConstants.MB_ADDITIONS));
			}
		});
		Menu menu = menuManager.createContextMenu(treeViewer.getTree());
		treeViewer.getTree().setMenu(menu);
		getSite().setSelectionProvider(selection);
		getSite().registerContextMenu(menuManager, selection);
		// Titlebar Menu
		IMenuManager rootMenuManager = getViewSite().getActionBars()
				.getMenuManager();
		rootMenuManager.setRemoveAllWhenShown(true);
		rootMenuManager.addMenuListener(new IMenuListener() {
			public void menuAboutToShow(IMenuManager mgr) {
				fillMenu(mgr);
			}
		});
		fillMenu(rootMenuManager);
	}
	/**
	 * Fill the SessionExplorerView's Titlebar dropdown menu 
	 */
	protected void fillMenu(IMenuManager rootMenuManager) {
		// These actions are being presented in the menu and so should have an icon
		hideStatics.setImageDescriptor(CorePlugin
				.getImageDescriptor("static_co.gif")); //$NON-NLS-1$
		rootMenuManager.add(hideStatics);
		rootMenuManager.add(filters);
		rootMenuManager.add(new Separator(
				IWorkbenchActionConstants.MB_ADDITIONS));
		rootMenuManager.add(linkWithEditor);
	}
	/**
	 * Create the view filters for the SessionExplorerView window
	 */
	protected void createFilters() {
		filterStatics = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				if (element instanceof Operation_c) {
					return (((Operation_c) element).getInstance_based() == Scope_c.Instance);
				}
				if (element instanceof Function_c) {
					return false;
				}
				return true;
			}
		};
		filterSystem = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof SystemModel_c);
			}
		};
		filterDomains = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof Domain_c);
			}
		};
		filterFunctions = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof Function_c);
			}
		};
		filterClasses = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof _c);
			}
		};
		filterInstances = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof Instance_c);
			}
		};
		filterValues = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof AttributeValue_c);
			}
		};
		filterPendingEvents = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof PendingEvent_c);
			}
		};
		filterClassStates = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof StateMachineState_c);
			}
		};
		filterStates = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof StateMachineState_c);
			}
		};
		filterRuntimeValues = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof _c);
			}
		};
		filterComponents = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof Component_c);
			}
		};
		filterComponentInstances = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof ComponentInstance_c);
			}
		};
		filterPorts = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof Port_c);
			}
		};
		filterProvisions = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof Provision_c);
			}
		};
		filterRequirements = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof Requirement_c);
			}
		};
		filterProvidedOperations = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof ProvidedOperation_c);
			}
		};
		filterProvidedSignals = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof ProvidedSignal_c);
			}
		};
		filterRequiredOperations = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof RequiredOperation_c);
			}
		};
		filterRequiredSignals = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof RequiredSignal_c);
			}
		};
		filterParameters = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof PropertyParameter_c);
			}
		};
		filterOperations = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof Operation_c);
			}
		};
		filterComponentReferences = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof ComponentReference_c);
			}
		};
		filterComponentReferenceInstances = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof ComponentInstance_c);
			}
		};
		filterAssociations = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof LinkParticipation_c);
			}
		};
		filterFunctionPackages = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof FunctionPackage_c);
			}
		};
		filterFunctionParameters = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof FunctionParameter_c);
			}
		};
		filterPackages = new ViewerFilter() {
			public boolean select(Viewer viewer, Object parentElement,
					Object element) {
				return !(element instanceof Package_c);
			}
		};
		SessionExplorerFiltersContentProvider contentProvider = new SessionExplorerFiltersContentProvider();
		String[] selections = contentProvider.getInitialSelections();
		updateFilters(selections);
	}
	/**
	 * Update the SessionExplorerView's view filters 
	 */
	public void updateFilters(String[] filters) {
		hideSystem.setChecked(false);
		updateFilter(hideSystem);
		hideDomains.setChecked(false);
		updateFilter(hideDomains);
		hideFunctions.setChecked(false);
		updateFilter(hideFunctions);
		hideClasses.setChecked(false);
		updateFilter(hideClasses);
		hideInstances.setChecked(false);
		updateFilter(hideInstances);
		hideValues.setChecked(false);
		updateFilter(hideValues);
		hidePendingEvents.setChecked(false);
		updateFilter(hidePendingEvents);
		hideClassStates.setChecked(false);
		updateFilter(hideClassStates);
		hideStates.setChecked(false);
		updateFilter(hideStates);
		hideRuntimeValues.setChecked(false);
		updateFilter(hideRuntimeValues);
		hideComponents.setChecked(false);
		updateFilter(hideComponents);
		hideComponentInstances.setChecked(false);
		updateFilter(hideComponentInstances);
		hidePorts.setChecked(false);
		updateFilter(hidePorts);
		hideProvisions.setChecked(false);
		updateFilter(hideProvisions);
		hideRequirements.setChecked(false);
		updateFilter(hideRequirements);
		hideProvidedOperations.setChecked(false);
		updateFilter(hideProvidedOperations);
		hideProvidedSignals.setChecked(false);
		updateFilter(hideProvidedSignals);
		hideRequiredOperations.setChecked(false);
		updateFilter(hideRequiredOperations);
		hideRequiredSignals.setChecked(false);
		updateFilter(hideRequiredSignals);
		hideParameters.setChecked(false);
		updateFilter(hideParameters);
		hideOperations.setChecked(false);
		updateFilter(hideOperations);
		hideComponentReferences.setChecked(false);
		updateFilter(hideComponentReferences);
		hideComponentReferenceInstances.setChecked(false);
		updateFilter(hideComponentReferenceInstances);
		hideAssociations.setChecked(false);
		updateFilter(hideAssociations);
		hideFunctionPackages.setChecked(false);
		updateFilter(hideFunctionPackages);
		hideFunctionParameters.setChecked(false);
		updateFilter(hideFunctionParameters);
		hidePackages.setChecked(false);
		updateFilter(hidePackages);
		for (int i = 0; i < filters.length; i++) {
			if (filters[i].equals("System")) {
				hideSystem.setChecked(true);
				updateFilter(hideSystem);
			}
			if (filters[i].equals("Domains")) {
				hideDomains.setChecked(true);
				updateFilter(hideDomains);
			}
			if (filters[i].equals("Functions")) {
				hideFunctions.setChecked(true);
				updateFilter(hideFunctions);
			}
			if (filters[i].equals("Classes")) {
				hideClasses.setChecked(true);
				updateFilter(hideClasses);
			}
			if (filters[i].equals("Instances")) {
				hideInstances.setChecked(true);
				updateFilter(hideInstances);
			}
			if (filters[i].equals("Values")) {
				hideValues.setChecked(true);
				updateFilter(hideValues);
			}
			if (filters[i].equals("PendingEvents")) {
				hidePendingEvents.setChecked(true);
				updateFilter(hidePendingEvents);
			}
			if (filters[i].equals("Class States")) {
				hideClassStates.setChecked(true);
				updateFilter(hideClassStates);
			}
			if (filters[i].equals("States")) {
				hideStates.setChecked(true);
				updateFilter(hideStates);
			}
			if (filters[i].equals("RuntimeValues")) {
				hideRuntimeValues.setChecked(true);
				updateFilter(hideRuntimeValues);
			}
			if (filters[i].equals("Components")) {
				hideComponents.setChecked(true);
				updateFilter(hideComponents);
			}
			if (filters[i].equals("Component Instances")) {
				hideComponentInstances.setChecked(true);
				updateFilter(hideComponentInstances);
			}
			if (filters[i].equals("Ports")) {
				hidePorts.setChecked(true);
				updateFilter(hidePorts);
			}
			if (filters[i].equals("Provisions")) {
				hideProvisions.setChecked(true);
				updateFilter(hideProvisions);
			}
			if (filters[i].equals("Requirements")) {
				hideRequirements.setChecked(true);
				updateFilter(hideRequirements);
			}
			if (filters[i].equals("Provided Operations")) {
				hideProvidedOperations.setChecked(true);
				updateFilter(hideProvidedOperations);
			}
			if (filters[i].equals("Provided Signals")) {
				hideProvidedSignals.setChecked(true);
				updateFilter(hideProvidedSignals);
			}
			if (filters[i].equals("Required Operations")) {
				hideRequiredOperations.setChecked(true);
				updateFilter(hideRequiredOperations);
			}
			if (filters[i].equals("Required Signals")) {
				hideRequiredSignals.setChecked(true);
				updateFilter(hideRequiredSignals);
			}
			if (filters[i].equals("Parameters")) {
				hideParameters.setChecked(true);
				updateFilter(hideParameters);
			}
			if (filters[i].equals("Operations")) {
				hideOperations.setChecked(true);
				updateFilter(hideOperations);
			}
			if (filters[i].equals("Component References")) {
				hideComponentReferences.setChecked(true);
				updateFilter(hideComponentReferences);
			}
			if (filters[i].equals("Component Reference Instances")) {
				hideComponentReferenceInstances.setChecked(true);
				updateFilter(hideComponentReferenceInstances);
			}
			if (filters[i].equals("Associations")) {
				hideAssociations.setChecked(true);
				updateFilter(hideAssociations);
			}
			if (filters[i].equals("Function Packages")) {
				hideFunctionPackages.setChecked(true);
				updateFilter(hideFunctionPackages);
			}
			if (filters[i].equals("Function Parameters")) {
				hideFunctionParameters.setChecked(true);
				updateFilter(hideFunctionParameters);
			}
			if (filters[i].equals("Packages")) {
				hidePackages.setChecked(true);
				updateFilter(hidePackages);
			}
		}
	}
	/**
	 * Update a single filter
	 */
	/* Multiple filters can be enabled at a time. */
	protected void updateFilter(Action action) {
		if (action == hideStatics) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterStatics);
			} else {
				treeViewer.removeFilter(filterStatics);
			}
			return;
		}
		if (action == hideSystem) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterSystem);
			} else {
				treeViewer.removeFilter(filterSystem);
			}
			return;
		}
		if (action == hideDomains) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterDomains);
			} else {
				treeViewer.removeFilter(filterDomains);
			}
			return;
		}
		if (action == hideFunctions) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterFunctions);
			} else {
				treeViewer.removeFilter(filterFunctions);
			}
			return;
		}
		if (action == hideClasses) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterClasses);
			} else {
				treeViewer.removeFilter(filterClasses);
			}
			return;
		}
		if (action == hideInstances) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterInstances);
			} else {
				treeViewer.removeFilter(filterInstances);
			}
			return;
		}
		if (action == hideValues) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterValues);
			} else {
				treeViewer.removeFilter(filterValues);
			}
			return;
		}
		if (action == hidePendingEvents) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterPendingEvents);
			} else {
				treeViewer.removeFilter(filterPendingEvents);
			}
			return;
		}
		if (action == hideClassStates) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterClassStates);
			} else {
				treeViewer.removeFilter(filterClassStates);
			}
			return;
		}
		if (action == hideStates) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterStates);
			} else {
				treeViewer.removeFilter(filterStates);
			}
			return;
		}
		if (action == hideRuntimeValues) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterRuntimeValues);
			} else {
				treeViewer.removeFilter(filterRuntimeValues);
			}
			return;
		}
		if (action == hideComponents) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterComponents);
			} else {
				treeViewer.removeFilter(filterComponents);
			}
			return;
		}
		if (action == hideComponentInstances) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterComponentInstances);
			} else {
				treeViewer.removeFilter(filterComponentInstances);
			}
			return;
		}
		if (action == hidePorts) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterPorts);
			} else {
				treeViewer.removeFilter(filterPorts);
			}
			return;
		}
		if (action == hideProvisions) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterProvisions);
			} else {
				treeViewer.removeFilter(filterProvisions);
			}
			return;
		}
		if (action == hideRequirements) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterRequirements);
			} else {
				treeViewer.removeFilter(filterRequirements);
			}
			return;
		}
		if (action == hideProvidedOperations) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterProvidedOperations);
			} else {
				treeViewer.removeFilter(filterProvidedOperations);
			}
			return;
		}
		if (action == hideProvidedSignals) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterProvidedSignals);
			} else {
				treeViewer.removeFilter(filterProvidedSignals);
			}
			return;
		}
		if (action == hideRequiredOperations) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterRequiredOperations);
			} else {
				treeViewer.removeFilter(filterRequiredOperations);
			}
			return;
		}
		if (action == hideRequiredSignals) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterRequiredSignals);
			} else {
				treeViewer.removeFilter(filterRequiredSignals);
			}
			return;
		}
		if (action == hideParameters) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterParameters);
			} else {
				treeViewer.removeFilter(filterParameters);
			}
			return;
		}
		if (action == hideOperations) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterOperations);
			} else {
				treeViewer.removeFilter(filterOperations);
			}
			return;
		}
		if (action == hideComponentReferences) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterComponentReferences);
			} else {
				treeViewer.removeFilter(filterComponentReferences);
			}
			return;
		}
		if (action == hideComponentReferenceInstances) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterComponentReferenceInstances);
			} else {
				treeViewer.removeFilter(filterComponentReferenceInstances);
			}
			return;
		}
		if (action == hideAssociations) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterAssociations);
			} else {
				treeViewer.removeFilter(filterAssociations);
			}
			return;
		}
		if (action == hideFunctionPackages) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterFunctionPackages);
			} else {
				treeViewer.removeFilter(filterFunctionPackages);
			}
			return;
		}
		if (action == hideFunctionParameters) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterFunctionParameters);
			} else {
				treeViewer.removeFilter(filterFunctionParameters);
			}
			return;
		}
		if (action == hidePackages) {
			if (action.isChecked()) {
				treeViewer.addFilter(filterPackages);
			} else {
				treeViewer.removeFilter(filterPackages);
			}
			return;
		}
	}
	/**
	 * Create the tool bar for the SessionExplorerView 
	 */
	protected void createToolbar() {
		IActionBars actionBars = getViewSite().getActionBars();
		actionBars.setGlobalActionHandler(ActionFactory.BACK.getId(), back);
		actionBars.setGlobalActionHandler(ActionFactory.FORWARD.getId(), fwd);
		actionBars.setGlobalActionHandler(ActionFactory.UP.getId(), up);
		IToolBarManager toolBarManager = actionBars.getToolBarManager();
		toolBarManager.add(back);
		toolBarManager.add(fwd);
		toolBarManager.add(up);
		toolBarManager.add(new Separator());
		toolBarManager.add(collapseAll);
		toolBarManager.add(linkWithEditor);
	}
	/*
	 * @see IWorkbenchPart#setFocus()
	 */
	public void setFocus() {
		Viewer viewer = getTreeViewer();
		if (viewer != null) {
			Control c = viewer.getControl();
			if (!c.isFocusControl()) {
				c.setFocus();
			}
		}
	}
	/**
	 * Returns an adapter if available
	 * @see IAdaptable#getAdapter
	 */
	public Object getAdapter(Class adapter) {
		if (adapter.equals(IPropertySheetPage.class)) {
			return getPropertySheet();
		}
		return super.getAdapter(adapter);
	}
	/**
	 * return a property sheet if available
	 */
	protected IPropertySheetPage getPropertySheet() {
		PropertySheetPage pss = new BridgepointPropertySheetPage();
		pss.setPropertySourceProvider(new ModelPropertySourceProvider());
		return pss;
	}
	/**
	 * Fire up an editor
	 */
	private IEditorPart handleOpen() {

		IStructuredSelection sel = (IStructuredSelection) selection
				.getSelection();
		if (sel.isEmpty()) {
			return null;
		}
		Object current = sel.iterator().next();
		String name = current.getClass().getName();
		//
		// Get the registry
		//
		IExtensionRegistry reg = Platform.getExtensionRegistry();
		//
		// Get all the plugins that have extended this point
		//
		IExtensionPoint extPt = reg
				.getExtensionPoint("com.mentor.nucleus.bp.core.editors"); //$NON-NLS-1$
		IExtension[] exts = extPt.getExtensions();
		// Repeat for each extension until we find a default editor
		for (int i = 0; i < exts.length; i++) {
			IConfigurationElement[] elems = exts[i].getConfigurationElements();
			for (int j = 0; j < elems.length; j++) {
				// Find the editor elements
				if (elems[j].getName().equals("editor")) { //$NON-NLS-1$
					IConfigurationElement[] edElems = elems[j].getChildren();
					for (int k = 0; k < edElems.length; k++) {
						//
						// Is this editor the default for the current model element ?
						//
						if (edElems[k].getName().equals("defaultFor") && //$NON-NLS-1$
								edElems[k].getAttribute("class").equals(name)) { //$NON-NLS-1$
							try {
								//
								// Get the class supplied for the input
								//
								Bundle bundle = Platform
										.getBundle(elems[j]
												.getDeclaringExtension()
												.getNamespace());
								Class inputClass = bundle.loadClass(elems[j]
										.getAttribute("input"));//$NON-NLS-1$
								Class[] type = new Class[1];
								type[0] = Object.class;
								//
								// Dynamically get the method createInstance, the supplied class must implement this
								//
								Method createInstanceMethod = inputClass
										.getMethod("createInstance", type); //$NON-NLS-1$
								Object[] args = new Object[1];
								args[0] = EditorUtil.getElementToEdit(current);
								//
								// Invoke the method.
								// The method is static; no instance is needed, so first argument is null
								//
								IEditorInput input = (IEditorInput) createInstanceMethod
										.invoke(null, args);
								//
								// pass the input to the Eclipse editor, along with the class name supplied by
								// the extending plugin.
								//
								if (input != null) {
									return PlatformUI
											.getWorkbench()
											.getActiveWorkbenchWindow()
											.getActivePage()
											.openEditor(
													input,
													elems[j].getAttribute("class")); //$NON-NLS-1$
								}
								return null;
							} catch (ClassNotFoundException e) {
								CorePlugin.logError("Input Class not found", e);
							} catch (NoSuchMethodException e) {
								CorePlugin
										.logError(
												"Class does not implement static method createInstance",
												e);
							} catch (InvocationTargetException e) {
								CorePlugin
										.logError(
												"Exception occured on invocation of static method createInstance of the Target",
												(Exception) e
														.getTargetException());
							} catch (IllegalAccessException e) {
								CorePlugin
										.logError(
												"Target does not support static method createInstance",
												e);
							} catch (PartInitException e) {
								CorePlugin.logError(
										"Could not activate Editor", e);
							}
						}
					}
				}
			}
		}

		return null;
	}
	/**
	 * Dispose of the SessionExplorerView widget
	 */
	public void dispose() {
		super.dispose();
		Ooaofooa.removeModelChangeListenerFromAll(m_modelChangeListener);
		TransactionManager.getSingleton().removeTransactionListener(
				m_transactionListener);
		selection.removeSelectionChangedListener(m_selChangedListener);
		getSite().getPage().removePartListener(m_partListener);
	}
	/**
	 * Initialize the Label provider to link it into the chain 
	 * of platform label decorators.
	 */
	protected void initLabelProvider(TreeViewer viewer) {
		viewer.setLabelProvider(new DecoratingLabelProvider(
				(ILabelProvider) viewer.getLabelProvider(), CorePlugin
						.getDefault().getWorkbench().getDecoratorManager()
						.getLabelDecorator()));
	}

	/**
	 * Sets whether this SessionExplorerView's selection is linked to that of the 
	 * whichever editor is currently open.  This method is used by
	 * automated test programs to simulate pressing/unpressing the 
	 * "Link with Editor" button of the SessionExplorerView.
	 */
	public void setLinkWithEditor(boolean link) {
		linkWithEditor.setChecked(link);
	}
	/**
	 * Have this explorer-view behave as if its open-action was just
	 * invoked. Returns the editor that was opened. For automated test purposes.
	 */
	public IEditorPart doOpen() {
		return handleOpen();
	}

	/**
	 * Have this explorer-view behave as if its delete-action was just
	 * invoked.  For automated test purposes.
	 */
	public void doDelete() {
		delete.run();
	}
}
